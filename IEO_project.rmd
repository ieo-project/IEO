---
title: "IEO_PROJECT"
author: "Javier Sánchez Utgés"
date: "30 de abril de 2019"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Analysis of TCGA RNA-seq dataset of kidney renal clear cell carcinoma

This is an R Markdown document that will show all the steps of the analysis of TCGA RNA-seq dataset of kidney renal clear cell carcinoma.

## 1. Introduction


## 2. Quality analysis

### 2.1. Data import
First, we import the dataset and store it in a `SummarizedExperiment` object, named `se`. This kind of object has genes on its rows and samples on its columns, 20,115 genes and 614 samples in our case. Both of these entities have their own associated metadata, i.e., gene symbol, lenght and GC content for genes. For samples, there are more than 500 more fields, for instance type, gender and race.

```{r data import, echo=FALSE}
library(SummarizedExperiment)
se <- readRDS(file.path("seKIRC.rds"))
se
```

Next, we explore the dimensions of the column data of the object, containing the samples data and see that it has 614 rows (samples) and 549 columns (metadata fields).

```{r Column data exploration, echo = FALSE}
dim(colData(se))
colData(se)[1:5, 1:5]
mcols(colData(se), use.names=TRUE)
```

These metadata consists of two columns of information about the clinical variables.
One called `labelDescription` contains a succint description of the variable, often
not more self-explanatory than the variable name itself, and the other called
'CDEID' corresponds to the so-called `Common Data Element (CDE)` identifier. This
identifier can be use in https://cdebrowser.nci.nih.gov to search for further
information about the associated clinical variable using the `Advanced search`
form and the `Public ID` attribute search.

We do the same with the gene data and observe the metadata mentioned before.

```{r Row data exploration, echo = FALSE, message = FALSE}
dim(rowData(se))
rowData(se)
```

To perform quality assessment and normalization we need first to load the
[edgeR](http://bioconductor.org/packages/edgeR) R/Bioconductor package and
create a `DGEList' object.

```{r DGE object creation}
library(edgeR)

dge <- DGEList(counts=assays(se)$counts, genes=mcols(se))
saveRDS(dge, file.path("results", "dge.rds"))
```

### 2.2. Within-sample normalization
Now calculate $\log_2$ CPM values of expression and put them as an additional
assay element to ease their manipulation.

```{r CPM calculation}
assays(se)$logCPM <- cpm(dge, log=TRUE, prior.count=0.5)
assays(se)$logCPM[1:5, 1:5]
```

### 2.3. Distribution and filtering of sequencing depth

Let's examine the sequencing depth in terms of total number of sequence read counts
mapped to the genome per sample.

```{r Sequencing depth}
ord <- order(dge$sample$lib.size)
barplot(dge$sample$lib.size[ord]/1e+06, las = 1, ylab = "Millions of reads", xlab = "Samples", col = c("red", "blue")[se$gender[ord]], border=NA, space=c(0,0))
legend("topleft", c("female", "male", "NA"), fill = c("red", "blue", "white"), inset = 0.02)
abline(h=(sum(colSums(assays(se)$counts))/1e6)/ncol(se))
```

EXPLAIN 21 THRESHOLD AND 614 --> 596

```{r Expression filtering among samples}
cpm_cutoff <- 21
mask <- colSums(assays(se)$counts)/1e6 > cpm_cutoff
se.filt <- se[, mask]
dge.filt <- dge[, mask]
dim(se.filt)
```

Store un-normalized versions of the data filtered by sample depth (cutoff of 21 CPM).

```{r}
saveRDS(se.filt, file.path("results", "se.filt.unnorm.rds"))
saveRDS(dge.filt, file.path("results", "dge.filt.unnorm.rds"))
```
### 2.4. Distribution of expression levels among samples

Let's look at the distribution of expression values per sample in terms of logarithmic CPM units. EXPLAIN PLOTS.

```{r Distribution of expression levels among samples}
library(geneplotter)

par(mfrow=c(1, 2))
multidensity(as.list(as.data.frame(assays(se[, se$type == "tumor"])$logCPM)),
             xlab="log 2 CPM", legend=NULL, main="tumor", las=1)
multidensity(as.list(as.data.frame(assays(se[, se$type == "normal"])$logCPM)),
             xlab="log 2 CPM", legend=NULL, main="normal", las=1)
```

### 2.5. Distribution and filtering of expression levels among genes

Let's calculate now the average expression per gene through all the samples.

```{r Distribution of expression levels among genes}

cpm_cutoff <- round(15/min(dge.filt$samples$lib.size/1e+06), digits = 1)
cpm_cutoff
nsamplescutoff <- min(table(se.filt$type))
nsamplescutoff
mask <- rowSums(cpm(dge.filt) > cpm_cutoff) >= nsamplescutoff
se.filt2 <- se.filt[mask, ]
dge.filt2 <- dge.filt[mask, ]
avgexp <- rowMeans(assays(se.filt)$logCPM)

par(mar = c(4, 5, 1, 1))
h <- hist(avgexp, xlab = expression("Expression level (" * log[2] * "CPM)"), main = "", 
    las = 1, col = "grey", cex.axis = 1.2, cex.lab = 1.5)
```

EXPLAIN THE DOUBLE CUTOFF.

```{r}
par(mar = c(4, 5, 1, 1))
h <- hist(avgexp, xlab = expression("Expression level (" * log[2] * "CPM)"), main = "", 
    las = 1, col = "grey", cex.axis = 1.2, cex.lab = 1.5)
x <- cut(rowMeans(assays(se.filt2)$logCPM), breaks = h$breaks)
lines(h$mids, table(x), type = "h", lwd = 10, lend = 1, col = "darkred")
legend("topleft", c("All genes", "Filtered genes"), fill = c("grey", "darkred"))
```

Store un-normalized versions of the data filtered by gene expression (cutoff of 0.6 CPM expressed in at least 72 samples).

```{r}
saveRDS(se.filt2, file.path("results", "se.filt2.unnorm.rds"))
saveRDS(dge.filt2, file.path("results", "dge.filt2.unnorm.rds"))
```

### 2.6. Between-sample normalization

We calculate now the normalization factors on the filtered expression data set.

```{r Between-sample normalization}
dge.filt2 <- calcNormFactors(dge.filt2)
dge.filt$samples$group <- se.filt$type
dge.filt2$samples$group <- se.filt2$type
table(dge.filt2$samples$group)
par(mfrow = c(1, 2))
plotSmear(dge.filt, lowess = TRUE, las = 1, cex.lab = 1.5, cex.axis = 1.2)
abline(h = 0, col = "blue", lwd = 2)
plotSmear(dge.filt2, lowess = TRUE, las = 1, cex.lab = 1.5, cex.axis = 1.2)
abline(h = 0, col = "blue", lwd = 2)
```

### 2.7. Batch Identification

EXPLANATION BATCHES and BATCH filtering

```{r Batch effect }
tss <- substr(colnames(se.filt2), 6, 7)
center <- substr(colnames(se.filt2), 27, 28)
plate <- substr(colnames(se.filt2), 22, 25)
portionanalyte <- substr(colnames(se.filt2), 18, 20)
samplevial <- substr(colnames(se.filt2), 14, 16)

table(data.frame(TYPE=se.filt2$type, TSS=tss))
table(data.frame(TYPE=se.filt2$type, PLATE=plate))
table(data.frame(TYPE=se.filt2$type, SAMPLEVIAL=samplevial))
table(data.frame(TYPE=se.filt2$type, PORTIONANALYTE=portionanalyte))

tss_list <- c("A3","B0","B2","B8","CW","CZ")
plate_list <- c(1503,1541,1672)
samplevial_list <- c("01A","11A")
portion <- "01R"
the_mask <- (substr(colnames(dge.filt),6,7) %in% tss_list & substr(colnames(dge.filt),22,25) %in% plate_list & substr(colnames(dge.filt),18,20) == portion & substr(colnames(dge.filt),14,16) %in% samplevial_list)

se.filt3 <- se.filt2[,the_mask]
dge.filt3 <- dge.filt2[,the_mask]

tss2 <- substr(colnames(se.filt3), 6, 7)
plate2 <- substr(colnames(se.filt3), 22, 25)
portionanalyte2 <- substr(colnames(se.filt3), 18, 20)
samplevial2 <- substr(colnames(se.filt3), 14, 16)

table(data.frame(TYPE=se.filt3$type, TSS=tss2))
table(data.frame(TYPE=se.filt3$type, PLATE=plate2))
table(data.frame(TYPE=se.filt3$type, SAMPLEVIAL=samplevial2))
table(data.frame(TYPE=se.filt3$type, PORTIONANALYTE=portionanalyte2))
```

### 2.8. Clustering according to batch effect

```{r Hierarchical clustering according to batch effect}
logCPM <- cpm(dge.filt3, log=TRUE, prior.count=3)
d <- as.dist(1-cor(logCPM, method="spearman"))
sampleClustering <- hclust(d)
batch <- as.integer(factor(tss2))
sampleDendrogram <- as.dendrogram(sampleClustering, hang=0.1)
names(batch) <- colnames(se.filt3)
outcome <- paste(substr(colnames(se.filt3), 9, 12), as.character(se.filt3$type), sep="-")
names(outcome) <- colnames(se.filt3)
sampleDendrogram <- dendrapply(sampleDendrogram,
                               function(x, batch, labels) {
                                 if (is.leaf(x)) {
                                   attr(x, "nodePar") <- list(lab.col=as.vector(batch[attr(x, "label")]))
                                   attr(x, "label") <- as.vector(labels[attr(x, "label")])
                                 }
                                 x
                               }, batch, outcome)
plot(sampleDendrogram, main="Hierarchical clustering of samples")
legend("topright", paste("Batch", sort(unique(batch)), levels(factor(tss2))), fill=sort(unique(batch)))

batch <- as.integer(factor(plate2))
sampleDendrogram <- as.dendrogram(sampleClustering, hang=0.1)
names(batch) <- colnames(se.filt3)
outcome <- paste(substr(colnames(se.filt3), 9, 12), as.character(se.filt3$type), sep="-")
names(outcome) <- colnames(se.filt3)
sampleDendrogram <- dendrapply(sampleDendrogram,
                               function(x, batch, labels) {
                                 if (is.leaf(x)) {
                                   attr(x, "nodePar") <- list(lab.col=as.vector(batch[attr(x, "label")]))
                                   attr(x, "label") <- as.vector(labels[attr(x, "label")])
                                 }
                                 x
                               }, batch, outcome)
plot(sampleDendrogram, main="Hierarchical clustering of samples")
legend("topright", paste("Batch", sort(unique(batch)), levels(factor(plate2))), fill=sort(unique(batch)))


batch <- as.integer(factor(samplevial2))
sampleDendrogram <- as.dendrogram(sampleClustering, hang=0.1)
names(batch) <- colnames(se.filt3)
outcome <- paste(substr(colnames(se.filt3), 9, 12), as.character(se.filt3$type), sep="-")
names(outcome) <- colnames(se.filt3)
sampleDendrogram <- dendrapply(sampleDendrogram,
                               function(x, batch, labels) {
                                 if (is.leaf(x)) {
                                   attr(x, "nodePar") <- list(lab.col=as.vector(batch[attr(x, "label")]))
                                   attr(x, "label") <- as.vector(labels[attr(x, "label")])
                                 }
                                 x
                               }, batch, outcome)
plot(sampleDendrogram, main="Hierarchical clustering of samples")
legend("topright", paste("Batch", sort(unique(batch)), levels(factor(samplevial2))), fill=sort(unique(batch)))

se.filt4 <- se.filt3[,grep("5546|5591", colnames(se.filt3), invert=TRUE)]
dge.filt4 <- dge.filt3[,grep("5546|5591", colnames(dge.filt3), invert=TRUE)]
se.dis <- se.filt3[,grep("5546|5591", colnames(se.filt3))]
tss3 <- substr(colnames(se.filt4), 6, 7)
plate3 <- substr(colnames(se.filt4), 22, 25)
portionanalyte3 <- substr(colnames(se.filt4), 18, 20)
samplevial3 <- substr(colnames(se.filt4), 14, 16)

```

### 2.8. Clustering according to batch effect

```{r}
colnames(dge.filt4) <- c(1:112)
colnames(se.filt4) <- c(1:112)
tumor_se <- se.filt4[,se.filt4$type == "tumor"]
tumor_dge <- dge.filt4[,se.filt4$type == "tumor"]

###GENDER
se_gender <- se.filt4[,!is.na(se.filt4$gender)]
dge_gender <- dge.filt4[,!is.na(se.filt4$gender)]
batch <- as.integer(factor(se_gender$gender))
outcome <- paste(factor(se_gender$gender), as.character(se_gender$type), sep="-")
plotMDS(dge_gender, col = batch,labels = outcome, cex = 0.7)
legend("topleft", paste("Batch", sort(unique(batch)), levels(factor(se_gender$gender))), fill=sort(unique(batch)), inset=0.005)

###CANCER STAGE
tumor_stage_se <- tumor_se[,!is.na(tumor_se$ajcc_pathologic_tumor_stage)]
tumor_stage_dge <-tumor_dge[,!is.na(tumor_se$ajcc_pathologic_tumor_stage)]
batch <- as.integer(factor(tumor_stage_se$ajcc_pathologic_tumor_stage))
outcome <- paste(factor(tumor_stage_se$ajcc_pathologic_tumor_stage), colnames(tumor_stage_se), sep="-")
plotMDS(tumor_stage_dge, col = batch,labels = outcome, cex = 0.7)
legend("bottomright", sort(unique(batch)), levels(factor(tumor_stage_se$ajcc_pathologic_tumor_stage)), fill=sort(unique(batch)), inset=0.005)

###TUMOR GRADE 
tumor_grade_se <- tumor_se[,!is.na(tumor_se$tumor_grade)]
tumor_grade_dge <-tumor_dge[,!is.na(tumor_se$tumor_grade)]
batch <- as.integer(factor(tumor_grade_se$tumor_grade))
outcome <- paste(factor(tumor_grade_se$tumor_grade), colnames(tumor_grade_se), sep="-")
plotMDS(tumor_grade_dge, col = batch,labels = outcome, cex = 0.7)
legend("bottomright", sort(unique(batch)), levels(factor(tumor_grade_se$tumor_grade)), fill=sort(unique(batch)), inset=0.005)

###CANCER laterality
tumor_lat_se <- tumor_se[,!is.na(tumor_se$laterality)]
tumor_late_dge <-tumor_dge[,!is.na(tumor_se$laterality)]
batch <- as.integer(factor(tumor_lat_se$laterality))
outcome <- paste(factor(tumor_lat_se$laterality), colnames(tumor_lat_se), sep="-")
plotMDS(tumor_stage_dge, col = batch,labels = outcome, cex = 0.7)
legend("topleft", sort(unique(batch)), levels(factor(tumor_lat_se$laterality)), fill=sort(unique(batch)), inset=0.005)

###CANCER status
tumor_status_se <- tumor_se[,!is.na(tumor_se$vital_status)]
tumor_status_dge <-tumor_dge[,!is.na(tumor_se$vital_status)]
batch <- as.integer(factor(tumor_status_se$vital_status))
outcome <- paste(factor(tumor_status_se$vital_status), colnames(tumor_status_se), sep="-")
plotMDS(tumor_status_dge, col = batch,labels = outcome, cex = 0.7)
legend("topleft", sort(unique(batch)), levels(factor(tumor_status_se$vital_status)), fill=sort(unique(batch)), inset=0.005)
```

## 3. Differential expression

```{r Differential expression}
library(sva)
mod <- model.matrix(~ se.filt4$type, colData(se.filt4))
mod0 <- model.matrix(~ 1, colData(se.filt4))
pv <- f.pvalue(assays(se.filt4)$logCPM, mod, mod0)
sum(p.adjust(pv, method="fdr")< 0.01)
hist(pv, main="",las=1)
```

Estimation of surrogate variables

```{r Estimation of surrogate variables}
sv <- sva(assays(se.filt4)$logCPM, mod, mod0)
sv$n
modsv <- cbind(mod, sv$sv)
mod0sv <- cbind(mod0, sv$sv)
pvsv <- f.pvalue(assays(se.filt4)$logCPM, modsv, mod0sv)
sum(p.adjust(pvsv,method="fdr")<0.01)
hist(pvsv, main="",las=1)
```

Fold change

```{r Fold change}
tumorExp <- rowMeans(logCPM[, se.filt4$type == "tumor"])
normalExp <- rowMeans(logCPM[, se.filt4$type == "normal"])
par(mfrow = c(1, 2))
plot(normalExp, tumorExp, xlab = "Tumor", ylab = "Normal", pch = ".", cex = 4, las = 1)
plot((tumorExp + normalExp)/2, tumorExp - normalExp, pch = ".", cex = 4, las = 1)

log2fc <- tumorExp - normalExp
ranking <- order(abs(log2fc), decreasing = TRUE)
head(data.frame(Log2FC = round(log2fc[ranking], digits = 3), FC = round(2^log2fc[ranking], 
    digits = 3), `1/FC` = round(2^(-log2fc[ranking]), digits = 3), row.names = rowData(se.filt4)$symbol[ranking], 
    check.names = FALSE), n = 10)
```

