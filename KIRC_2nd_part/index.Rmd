---
title: "Analysis of a TCGA RNA-seq data set on Kidney Clear Cell Carcinoma"
author:
- name: J. Sanchez
  affiliation:
  - &id Master Programme on Bioinformatics for Health Sciences, Universitat Pompeu Fabra, Barcelona, Catalonia
  email: javier.sanchez14@estudiant.upf.edu
- name: P. Badia
  affiliation: *id
  email: pau.badia01@estudiant.upf.edu
- name: G. Palou 
  affiliation: *id
  email: guillermo.palou@upf.edu
date: "`r format(Sys.time(), '%B %e, %Y')`"
output:
  BiocStyle::html_document:
    toc: true
    fig_caption: yes
    toc_float: true
    number_sections: true
bibliography: bibliography.bib
---

# Introduction

Kidney Clear Cell Carcinoma or clear cell renal cell carcinoma (ccRCC), is a chemotherapy-resistant disease that can be distinguished of other cancer because affected cells show a clear cytoplasm, are surrounded by a distinct cell membrane and contain round and uniform nuclei. Inherited predisposition to ccRCC has been shown to arise from genes involved
in regulating cellular metabolism, making ccRCC a model for the role of an oncologic-metabolic shift.
The Cancer Genome Atlas (TCGA) has comprehensively profiled this type of cancer
in a patient cohort. Here we analyze the expression profiles of those
patients, accessible in the form of a raw RNA-seq counts produced by
@natureTCGA using a pipeline based on the R/Bioconductor
software package `Rsubread`.

This document is written in [R markdown](https://rmarkdown.rstudio.com) and
should be processed using R and you need to install the packages
`r CRANpkg("knitr")` and `r CRANpkg("markdown")`. Moreover, it using the official
style for Bioconductor vignettes facilitated by the Bioconductor package
`r Biocpkg("BiocStyle")`. Please consult that package documentation, and particularly
the [vignette](http://bioconductor.org/packages/release/bioc/vignettes/BiocStyle/inst/doc/AuthoringRmdVignettes.html)
on "Authoring R Markdown vignettes", for full details on how to elaborate this
kind of documents.

The specific instructions to generate the final HTML report are written in a
[Makefile](https://en.wikipedia.org/wiki/Makefile). To run it you just need to type

   ```
   $ make
   ```

on the unix shell. The `makefile` contains instructions to separately process
the different files that integrate this report, and so only the file that has
been modified will be rebuilt. If you wish to remove or add files to be processed,
you should modify the `makefile`.

The directory `results` will contain resulting files produced during the analysis,
however, figures are going to end by default directories associated with the
source filenames from where they were created.

# Quality analysis

Before starting, we need to import all the libraries that are going to be used in this analysis.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.align="center")
```


```{r libraries, results = 'hide', message=FALSE, warning=FALSE}
library(knitr)
library(SummarizedExperiment)
library(edgeR)
library(geneplotter)
library(sva)
library(ggplot2)
```

## Data import

First, we import the dataset and store it in a `SummarizedExperiment` object, named `se`. This kind of object has genes on its rows and samples on its columns, 20115 genes and 614 samples in our case. Both of these entities have their own associated metadata, i.e., gene symbol, lenght and GC content for genes. For samples, there are more than 500 more fields, for instance type, gender and race.

```{r dataImp, echo=TRUE}
se <- readRDS(file.path("input","seKIRC.rds"))
se
```

Next, we explore the dimensions of the column data of the `se` object, containing the samples data and we observe that it has 614 rows (samples) and 549 columns (metadata fields). To see the possible values that each clinical variable can have we use `mcols` function.

```{r colData, echo = TRUE}
dim(colData(se))
colData(se)[1:5, 1:5]
mcols(colData(se), use.names=TRUE)
```

These metadata consists of two columns of information about the clinical variables.
One called `labelDescription` contains a succint description of the variable, often
not more self-explanatory than the variable name itself, and the other called
'CDEID' corresponds to the so-called `Common Data Element (CDE)` identifier. This
identifier can be use in https://cdebrowser.nci.nih.gov to search for further
information about the associated clinical variable using the `Advanced search`
form and the `Public ID` attribute search.

We do the same with the gene data and observe the metadata mentioned before.

```{r rowData, echo = FALSE, message = TRUE}
dim(rowData(se))
rowData(se)
```

To perform quality assessment and normalization we use the [edgeR](http://bioconductor.org/packages/edgeR) R/Bioconductor package and create a `DGEList` objec, which we are going to save in the file `dge.rds`.

```{r DGE, include=TRUE}
dge <- DGEList(counts=assays(se)$counts, genes=mcols(se))
saveRDS(dge, file.path("results", "dge.rds"))
```

## Within-sample normalization
Now we calculate $\log_2$ CPM values of expression and put them as an additional
assay element to ease their manipulation.

```{r CPM}
assays(se)$logCPM <- cpm(dge, log=TRUE, prior.count=0.5)
assays(se)$logCPM[1:5, 1:5]
```

## Filtering of sequencing depth (first filtering)

We then examine the sequencing depth in terms of total number of sequence read counts mapped to the genome per sample and filter those samples that have less than 20M reads, with the goal of having samples with a sufficient amount of reads so meaningful inferences can be made from this analysis. This filtering removes 13 samples from our dataset, leaving a total of 601 samples. We then save the new filtered `se` and `dge` objects with new names, `.filt`.

```{r exp_filt_samples}
cpm_cutoff <- 20
mask <- colSums(assays(se)$counts)/1e6 > cpm_cutoff
se.filt <- se[, mask]
dge.filt <- dge[, mask]
dim(se.filt)
```

## Paired samples selection (second filtering)

We now select the paired samples from the dataset, i.e., individuals from which there are both tumorous and healthy tissue samples, since the comparison of these kind of samples will give more statistical power to our analysis. This step removes most of the samples, leaving a total of 142 samples, 71 tomorous and 71 healthy, i.e., each one of them coming from a different individual, 71 individuals. We then save the new filtered `se` and `dge` objects with new names, `.filt2`.

```{r}
normal_IDs <- substr(colnames(se.filt[,se.filt$type=="normal"]),1,12)
tumor_IDs <- substr(colnames(se.filt[,se.filt$type=="tumor"]),1,12)
IDs <- substr(colnames(se.filt),1,12)
paired_mask <- IDs %in% normal_IDs & IDs %in% tumor_IDs
se.filt2 <- se.filt[,paired_mask]
dge.filt2<- dge.filt[, paired_mask]
colData(se.filt2)[1:5,1:5]
```

## Distribution of sequencing depth

We now analyze the sequencing depth of our paired samples, with a minimum of 20M reads and check that the gender of the samples is not correlated with the sequencing depth.

```{r seqDepth, dpi=200, fig.width=14, fig.height=8, fig.align = "center", fig.cap="Library sizes in increasing order"}
ord <- order(dge.filt2$sample$lib.size)
#summary(dge.filt2$sample$lib.size/1e+06)
barplot(dge.filt2$sample$lib.size[ord]/1e+06, las = 1, ylab = "Millions of reads", xlab = "Samples", col = c("red", "blue")[se.filt2$gender[ord]], space=c(0,0))
legend("topleft", c("female", "male"), fill = c("red", "blue"), inset = 0.02)
abline(h=(sum(colSums(assays(se.filt2)$counts))/1e6)/ncol(se.filt2))
```

Figure \@ref(fig:seqDepth) shows the sequencing depth per sample, also known as library size, in increasing order. There is a good distribution of male and female samples with different sequencing depth. However, there is a huge difference between some samples, taking into account that the average is around 50 million reads. However, this will not affect the results, since 20M is an acceptable library size.

We store un-normalized data from the paired samples filtered by sequencing depth (cutoff of 20 CPM).

```{r}
saveRDS(se.filt2, file.path("results", "se.filt2.unnorm.rds"))
saveRDS(dge.filt2, file.path("results", "dge.filt2.unnorm.rds"))
```

## Distribution of expression levels among samples

We look at the distribution of expression values per sample in terms of logarithmic CPM units using [geneplotter](http://bioconductor.org/packages/geneplotter) R/Bioconductor package.

```{r distRawExp, fig.align="center", dpi=200, fig.width=14, fig.height=7, fig.cap="Non-parametric density distribution of expression profiles per sample"}
assays(se.filt2)$logCPM <- cpm(dge.filt2, log=TRUE, prior.count=0.5)
par(mfrow=c(1, 2))
multidensity(as.list(as.data.frame(assays(se.filt2[, se.filt2$type == "tumor"])$logCPM)),
             xlab="log 2 CPM", legend=NULL, main="tumor", las=1)
multidensity(as.list(as.data.frame(assays(se.filt2[, se.filt2$type == "normal"])$logCPM)),
             xlab="log 2 CPM", legend=NULL, main="normal", las=1)
```

Figure \@ref(fig:distRawExp) shows that the normal samples have a good CPM distribution, but some of the tumor samples seem to have a distinct RNA composition. Let's see if this can be fixed later on by filtering.

## Distribution and filtering of expression levels among genes (third filtering)

Now we calculate the average expression per gene through all the samples, and plot the distribution of expression levels across genes (Figure \@ref(fig:exprDist). It allows us to identify lowly expressed genes.

```{r exprDist, fig.align = "center", fig.width=14, fig.height=7, fig.cap="Distribution of average expression level per gene"}
avgexp <- rowMeans(assays(se.filt2)$logCPM)
par(mar = c(4, 5, 1, 1))
h <- hist(avgexp, xlab = expression("Expression level (" * log[2] * "CPM)"), main = "", 
    las = 1, col = "grey", cex.axis = 1.2, cex.lab = 1.5)
```

RNA-seq expression profiles from lowly-expressed genes can lead to artifacts in downstream differential expression analyses. For this reason, we remove them following this criteria:

- Filter out genes with fewer than a given number of samples meeting a minimu expression (logCPM) cut-off.

In our case, the minimum CPM is 0.6 in at least 72 samples, which is the sample size of the control group.

```{r exprDistFilt, fig.align = "center", fig.width=14, fig.height=7, fig.cap="Distribution of average expression level per gene, showing the filtered genes in red"}
# CPM cutoff
cpm_cutoff <- round(15/min(dge.filt2$samples$lib.size/1e+06), digits = 1)
#cpm_cutoff
nsamplescutoff <- min(table(se.filt2$type))
#nsamplescutoff
mask <- rowSums(cpm(dge.filt2) > cpm_cutoff) >= nsamplescutoff
se.filt3 <- se.filt2[mask, ]
dge.filt3 <- dge.filt2[mask, ]
# Plot
par(mar = c(4, 5, 1, 1))
h <- hist(avgexp, xlab = expression("Expression level (" * log[2] * "CPM)"), main = "", 
    las = 1, col = "grey", cex.axis = 1.2, cex.lab = 1.5)
x <- cut(rowMeans(assays(se.filt3)$logCPM), breaks = h$breaks)
lines(h$mids, table(x), type = "h", lwd = 10, lend = 1, col = "darkred")
legend("topleft", c("All genes", "Filtered genes"), fill = c("grey", "darkred"))
```

After the filtering, we remove most of the lowly-expressed genes, a total of 6585, keeping just 13330 of the original 20115 but as we can observe in Figure \@ref(fig:exprDistFilt) still some of them are not removed (negative log2 CPM). These are lowly-expressed genes that only are expressed in normal samples (thus follows the criteria). Because they are not expressed in tumor samples, the average CPM is negative. However, genes that are expressed, although not very significantly, in normal samples but not in tumor onees might be of interest.

We store the un-normalized versions of the data filtered by gene expression (cutoff of 0.6 CPM expressed in at least 72 samples).

```{r}
saveRDS(se.filt3, file.path("results", "se.filt3.unnorm.rds"))
saveRDS(dge.filt3, file.path("results", "dge.filt3.unnorm.rds"))
```

## Between-sample normalization

We calculate now the normalization factors on the filtered expression data set and compare the corresponding plot (Figure \@ref(fig:bsNorm) rigth) with the unnormalized expression data set (Figure \@ref(fig:bsNorm) left). 

```{r bsNorm, fig.align = "center", dpi=200, fig.width=14, fig.height=7, fig.cap="Normalized filtered expression data (right) and unnormalized unfiltered expression data (left)"}
#Unnormalized first filtered data set
par(mfrow = c(1, 2))
dge.filt2$samples$group <- se.filt2$type
plotSmear(dge.filt2, lowess = TRUE, las = 1, cex.lab = 1.5, cex.axis = 1.2)
abline(h = 0, col = "blue", lwd = 2)
#Normalized second filtered dataset
dge.filt3 <- calcNormFactors(dge.filt3)
dge.filt3$samples$group <- se.filt3$type
plotSmear(dge.filt3, lowess = TRUE, las = 1, cex.lab = 1.5, cex.axis = 1.2)
abline(h = 0, col = "blue", lwd = 2)

#table(dge.filt2$samples$group)
```

After the normalization on the filtered expression data we correct two previous artifacts:

1) A majority of genes seem to be upregulated under a condition where we do not expect it.

2) Large fold changes tend to occur at low expression levels (orange color in the left plot), because ratios between low numbers may easy lead to large fold-changes.

## Batch Identification

Using the TCGA barcode from the samples we can asses whether the plate idenfitier, tissue source site, portion analyte, sample vial and center can work as surrogates for batch effect indicators.

```{r batchEffect}
tss <- substr(colnames(se.filt3), 6, 7)
center <- substr(colnames(se.filt3), 27, 28)
plate <- substr(colnames(se.filt3), 22, 25)
portionanalyte <- substr(colnames(se.filt3), 18, 20)
samplevial <- substr(colnames(se.filt3), 14, 16)

table(data.frame(TYPE=se.filt2$type, TSS=tss))
table(data.frame(TYPE=se.filt2$type, CENTER=center))
table(data.frame(TYPE=se.filt2$type, PLATE=plate))
table(data.frame(TYPE=se.filt2$type, SAMPLEVIAL=samplevial))
table(data.frame(TYPE=se.filt2$type, PORTIONANALYTE=portionanalyte))

```

We can see that the distribution of the samples across the different variables is quite uniform, since they are paired samples, however some of them are not balanced, such as samplevial and portion analyte. We will not remove any samples, since we are going to include these variables in our model and adjust for the, so the inferences about differential gene expression are accurate.

## Batch effect: hierarchical clustering (fourth filtering)

We perform a hierarchical clustering of the samples indicating the batch to which each of them belongs to, to check if there is still some batch that might be confounding the outcome of interest.

```{r hiercClust1, fig.align = "center", dpi=200, fig.width=14, fig.height=8, fig.cap="Hierarchical clustering of the samples, colored by Tissue Source Site (TSS)"}
logCPM <- cpm(dge.filt3, log=TRUE, prior.count=3)
d <- as.dist(1-cor(logCPM, method="spearman"))
sampleClustering <- hclust(d)

## Batch: Tissue Source Site (TSS)
batch <- as.integer(factor(tss))
sampleDendrogram <- as.dendrogram(sampleClustering, hang=0.1)
names(batch) <- colnames(se.filt3)
outcome <- paste(substr(colnames(se.filt3), 9, 12), as.character(se.filt3$type), sep="-")
names(outcome) <- colnames(se.filt3)
sampleDendrogram <- dendrapply(sampleDendrogram,
                               function(x, batch, labels) {
                                 if (is.leaf(x)) {
                                   attr(x, "nodePar") <- list(lab.col=as.vector(batch[attr(x, "label")]))
                                   attr(x, "label") <- as.vector(labels[attr(x, "label")])
                                 }
                                 x
                               }, batch, outcome)
plot(sampleDendrogram, main="Hierarchical clustering of samples colored by TSS")
legend("topright", paste("Batch", sort(unique(batch)), levels(factor(tss))), fill=sort(unique(batch)))
```

```{r hiercClust2, fig.align = "center", dpi=200, fig.width=14, fig.height=8, fig.cap="Hierarchical clustering of the samples, colored by Plate"}
## Batch: Plate
batch <- as.integer(factor(plate))
sampleDendrogram <- as.dendrogram(sampleClustering, hang=0.1)
names(batch) <- colnames(se.filt3)
outcome <- paste(substr(colnames(se.filt3), 9, 12), as.character(se.filt3$type), sep="-")
names(outcome) <- colnames(se.filt3)
sampleDendrogram <- dendrapply(sampleDendrogram,
                               function(x, batch, labels) {
                                 if (is.leaf(x)) {
                                   attr(x, "nodePar") <- list(lab.col=as.vector(batch[attr(x, "label")]))
                                   attr(x, "label") <- as.vector(labels[attr(x, "label")])
                                 }
                                 x
                               }, batch, outcome)
plot(sampleDendrogram, main="Hierarchical clustering of samples colored by plate")
legend("topright", paste("Batch", sort(unique(batch)), levels(factor(plate))), fill=sort(unique(batch)))
```

```{r hiercClust3, fig.align = "center", dpi=200, fig.width=14, fig.height=8, fig.cap="Hierarchical clustering of the samples, colored by Sample Vial"}
## Batch: Sample Vial
batch <- as.integer(factor(samplevial))
sampleDendrogram <- as.dendrogram(sampleClustering, hang=0.1)
names(batch) <- colnames(se.filt3)
outcome <- paste(substr(colnames(se.filt3), 9, 12), as.character(se.filt3$type), sep="-")
names(outcome) <- colnames(se.filt3)
sampleDendrogram <- dendrapply(sampleDendrogram,
                               function(x, batch, labels) {
                                 if (is.leaf(x)) {
                                   attr(x, "nodePar") <- list(lab.col=as.vector(batch[attr(x, "label")]))
                                   attr(x, "label") <- as.vector(labels[attr(x, "label")])
                                 }
                                 x
                               }, batch, outcome)
plot(sampleDendrogram, main="Hierarchical clustering of samples colored by sample vial")
legend("topright", paste("Batch", sort(unique(batch)), levels(factor(samplevial))), fill=sort(unique(batch)))
```


```{r hiercClust4, fig.align = "center", dpi=200, fig.width=14, fig.height=8, fig.cap="Hierarchical clustering of the samples, colored by Portion Analyte"}
## Batch: Portion annalyte
batch <- as.integer(factor(portionanalyte))
sampleDendrogram <- as.dendrogram(sampleClustering, hang=0.1)
names(batch) <- colnames(se.filt3)
outcome <- paste(substr(colnames(se.filt3), 9, 12), as.character(se.filt3$type), sep="-")
names(outcome) <- colnames(se.filt3)
sampleDendrogram <- dendrapply(sampleDendrogram,
                               function(x, batch, labels) {
                                 if (is.leaf(x)) {
                                   attr(x, "nodePar") <- list(lab.col=as.vector(batch[attr(x, "label")]))
                                   attr(x, "label") <- as.vector(labels[attr(x, "label")])
                                 }
                                 x
                               }, batch, outcome)
plot(sampleDendrogram, main="Hierarchical clustering of samples colored by portion analyte")
legend("topright", paste("Batch", sort(unique(batch)), levels(factor(portionanalyte))), fill=sort(unique(batch)))
```


All three dendograms (Figures \@ref(fig:hiercClust1), \@ref(fig:hiercClust2) and \@ref(fig:hiercClust3)) seem to confirm the absence of any batch effect. Nevertheless, there are 4 pairs of samples that are suspicious, this is 4 tumor samples that cluster with the normal ones:  4619, 5636, 5681 and 5591. We can see that the normal 5591 sample clusters perfectly with the tumor samples, so we deduced that this could be a labeling error. The other three, however have both their normal and tumor samples clustering with the normal ones. This could maybe mean that these tumor samples are in an early stage of the cancer development. Moreover, on the tumor samples, we have two clear outliers, 5989 and 6087, whose normal samples do not cluster unappropiately. For inference reasons, we discarded all of these samples and saved them in another object. This leaves us with 65 paired samples (130 in total).

```{r hiercClustFilt}
se.filt4 <- se.filt3[,grep("5591|5636|4619|5681|6087|5989", colnames(se.filt3), invert=TRUE)]
dge.filt4 <- dge.filt3[,grep("5591|5636|4619|5681|6087|5989", colnames(dge.filt3), invert=TRUE)]
se.dis <- se.filt3[,grep("5591|5636|4619|5681|6087|5989", colnames(se.filt3))]

tss2 <- substr(colnames(se.filt4), 6, 7)
plate2 <- substr(colnames(se.filt4), 22, 25)
portionanalyte2 <- substr(colnames(se.filt4), 18, 20)
samplevial2 <- substr(colnames(se.filt4), 14, 16)

dim(dge.filt4)
table(se.filt4$type)

table(data.frame(TYPE=se.filt4$type, TSS=tss2))
table(data.frame(TYPE=se.filt4$type, PLATE=plate2))
table(data.frame(TYPE=se.filt4$type, SAMPLEVIAL=samplevial2))
table(data.frame(TYPE=se.filt4$type, PORTIONANALYTE=portionanalyte2))
```

## Batch effect: Multidimensional scaling

Now we make use of multidimensional scaling plots to check, first if there is a batch effect by gender?, and second other potential variables that might be a new outcome of interest in tumor samples: cancer stage, tumor grade, cancer laterality, and vital status

```{r MDSPlot1, fig.align="center", dpi = 200, fig.width=14, fig.height=8, fig.cap="Multidimensional Scaling Plot for the batch effect of Gender"}
tumor_se <- se.filt4[,se.filt4$type == "tumor"]
tumor_dge <- dge.filt4[,se.filt4$type == "tumor"]

## Gender
se_gender <- se.filt4[,!is.na(se.filt4$gender)]
dge_gender <- dge.filt4[,!is.na(se.filt4$gender)]
batch <- as.integer(factor(se_gender$gender))
outcome <- paste(factor(se_gender$type), substr(colnames(dge_gender), 9, 12), sep="-")
plotMDS(dge_gender, col = batch,labels = outcome, cex = 0.7)
legend("bottomleft", paste("Batch", sort(unique(batch)), levels(factor(se_gender$gender))), fill=sort(unique(batch)), inset=0.005)
```

```{r MDSPlot2, fig.align="center", dpi = 200, fig.width=14, fig.height=8, fig.cap="Multidimensional Scaling Plot for the outcome of interest Cancer Stage"}
## Cancer stage
#tumor_se <- se.filt3[,se.filt3$type == "tumor"]
#tumor_dge <- dge.filt3[,se.filt3$type == "tumor"]

tumor_stage_se <- tumor_se[,!is.na(tumor_se$ajcc_pathologic_tumor_stage)]
tumor_stage_dge <-tumor_dge[,!is.na(tumor_se$ajcc_pathologic_tumor_stage)]
batch <- as.integer(factor(tumor_stage_se$ajcc_pathologic_tumor_stage))
outcome <- substr(colnames(tumor_stage_dge), 9, 12)
plotMDS(tumor_stage_dge, col = batch,labels = outcome, cex = 0.7)
legend("topright", sort(unique(batch)), levels(factor(tumor_stage_se$ajcc_pathologic_tumor_stage)), fill=sort(unique(batch)), inset=0.005)
```

```{r MDSPlot3, fig.align="center", dpi = 200, fig.width=14, fig.height=8, fig.cap="Multidimensional Scaling Plot for for the outcome of interest Tumor Grade"}
## Tumor grade
tumor_grade_se <- tumor_se[,!is.na(tumor_se$tumor_grade)]
tumor_grade_dge <-tumor_dge[,!is.na(tumor_se$tumor_grade)]
batch <- as.integer(factor(tumor_grade_se$tumor_grade))
outcome <- substr(colnames(tumor_grade_dge), 9, 12)
plotMDS(tumor_grade_dge, col = batch,labels = outcome, cex = 0.7)
legend("topright", sort(unique(batch)), levels(factor(tumor_grade_se$tumor_grade)), fill=sort(unique(batch)), inset=0.005)
```

```{r MDSPlot4, fig.align="center", dpi = 200, fig.width=14, fig.height=8, fig.cap="Multidimensional Scaling Plot for for the outcome of interest Cancer Laterality"}
## Cancer laterality
tumor_late_se <- tumor_se[,!is.na(tumor_se$laterality)]
tumor_late_dge <-tumor_dge[,!is.na(tumor_se$laterality)]
batch <- as.integer(factor(tumor_late_se$laterality))
outcome <- substr(colnames(tumor_late_dge), 9, 12)
plotMDS(tumor_late_dge, col = batch,labels = outcome, cex = 0.7)
legend("topright", sort(unique(batch)), levels(factor(tumor_late_se$laterality)), fill=sort(unique(batch)), inset=0.005)
```

```{r MDSPlot5, fig.align="center", dpi = 200, fig.width=14, fig.height=8, fig.cap="Multidimensional Scaling Plot for for the outcome of interest Vital Status"}
## Vital status
tumor_status_se <- tumor_se[,!is.na(tumor_se$vital_status)]
tumor_status_dge <-tumor_dge[,!is.na(tumor_se$vital_status)]
batch <- as.integer(factor(tumor_status_se$vital_status))
outcome <- substr(colnames(tumor_status_dge), 9, 12)
plotMDS(tumor_status_dge, col = batch,labels = outcome, cex = 0.7)
legend("topright", sort(unique(batch)), levels(factor(tumor_status_se$vital_status)), fill=sort(unique(batch)), inset=0.005)
```

The first plot (figure \@ref(fig:MDSPlot1)) shows that there is no correlation between the gender and the logarithm of the fold change for the genes among the samples, which clusters them according to the outcome of interest (tumor or normal), for males and females are uniformly distributed among the two groups, considereing that there are more males than females.The rest of the plots (figures \@ref(fig:MDSPlot2), \@ref(fig:MDSPlot3), \@ref(fig:MDSPlot4), \@ref(fig:MDSPlot5)) do not show any cluster by the new outcomes of interest in the tumor samples, rejecting the alternative hypothesis of significant differences among the groups in the four variables (although it should be statistically tested in order to properly confirm it).

# Differential expression

We perform a simple examination of expression changes and their associated p-values using the [sva](http://bioconductor.org/packages/sva) R/bionconductor package.

```{r diffExp, fig.align="center", fig.cap="Distribution of raw p-values for an F-test on every gene between tumor and normal samples"}

# Creating the linear regression model and adjusting for covariates
mod <- model.matrix(~factor(se.filt4$type) + factor(tss2)+ factor(plate2)+ factor(portionanalyte2) , colData(se.filt4))
fit <- lmFit(assays(se.filt4)$logCPM, mod)
fit <- eBayes(fit)
FDRcutoff <- 0.01
res <- decideTests(fit, p.value = FDRcutoff)
summary(res)
# Showing the most significant DE genes with added metadata
genesmd <- data.frame(chr = as.character(seqnames(rowRanges(se.filt4))), symbol = rowData(se.filt4)[,1], stringsAsFactors = FALSE)
fit$genes <- genesmd
tt <- topTable(fit, coef = 2, n = Inf)
# DE genes per chromosome --> maybe look for another interesting variable
sort(table(tt$chr[tt$adj.P.Val < FDRcutoff]), decreasing = TRUE)

sum(tt$P.Value<FDRcutoff)

par(mfrow = c(1, 2), mar = c(4, 5, 2, 2))
hist(tt$P.Value, xlab = "Raw P-values", main = "", las = 1)
qqt(fit$t[, 2], df = fit$df.prior + fit$df.residual, main = "", pch = ".", cex = 3)
abline(0, 1, lwd = 2)

# Adjusting for unknown covariates

mod0 <- model.matrix(~factor(tss2) + factor(plate2) + factor(portionanalyte2), colData(se.filt4))
sv <- sva(assays(se.filt4)$logCPM, mod = mod, mod0 = mod0)
sv$n
mod <- cbind(mod, sv$sv)
colnames(mod) <- c(colnames(mod)[1:16], paste0("SV", 1:sv$n))
fit2 <- lmFit(assays(se.filt4)$logCPM, mod)
fit2 <- eBayes(fit2)
fit2$genes <- genesmd
tt2 <- topTable(fit2, coef = 2, n = Inf)
#A
par(mfrow = c(1, 2), mar = c(4, 5, 2, 2))
hist(tt2$P.Value, xlab = "Raw P-values", main = "", las = 1)
qqt(fit2$t[, 2], df = fit2$df.prior + fit2$df.residual, main = "", pch = ".", cex = 3)
abline(0, 1, lwd = 2)

sum(tt2$P.Value<FDRcutoff)
```

There are 10640 genes changing significantly their expression at FDR < 1%. Figure \@ref(fig:diffExp) from above shows the distribution of the resulting p-values.

## Estimation of surrogate variables

Surrogate variables are sources of hereogeneity in high-throughput profiling data, such as non-biological variability introduced by batch effects. We use the  to estimate the surrogate variables and adjust by these confounding effects. The previous model matrices are needed.

```{r Estimation of surrogate variables}
sv <- sva(assays(se.filt4)$logCPM, mod, mod0)
sv$n
```

The SVA algorithm has found 18 surrogate variables. Now, we use them to assess against the extent of differential expression, this time adjusting for these surrogate variables.

```{r diffExpAdj, fig.align="center", fig.cap="Distribution of raw p-values for an F-test on every gene between tumor and normal samples, after SVA"}
#modsv <- cbind(mod, sv$sv)
#mod0sv <- cbind(mod0, sv$sv)
pvsv <- f.pvalue(assays(se.filt4)$logCPM, modsv, mod0sv)
sum(p.adjust(pvsv,method="fdr")<0.01)
hist(pvsv, main="",las=1)
```

We have increased the number of changing genes to 12031. Figure \@ref(fig:diffExpAdj) from above shows the distribution of the resulting p-values.

```{r LIMMA}
#mod2 <- model.matrix(~factor(se.filt4$type) + factor(tss3) + factor(plate3), data = colData(se.filt4))
fit <- lmFit(assays(se.filt4)$logCPM,mod)
fit <- eBayes(fit, trend = TRUE)
#res <- decideTests(fit)
#summary(res)
FDRcutoff <- 0.01
res <- decideTests(fit, p.value = FDRcutoff)
#summary(res)
genesmd <- data.frame(chr = as.character(seqnames(rowRanges(se.filt4))), symbol = rowData(se.filt4)[,
1], stringsAsFactors = FALSE, logCPM = as.numeric(rowMeans(assays(se.filt4)$logCPM)))
fit$genes <- genesmd
tt <- topTable(fit, coef = 2, n = Inf)
sort(table(tt$chr[tt$adj.P.Val < FDRcutoff]), decreasing = TRUE)

hist(tt$P.Value, xlab = "Raw P-values", main = "", las = 1)

sum(tt[,tt$adj.P.Val<FDRcutoff])
fit$logCPM <- data.frame(logCPM = as.numeric(rowMeans(assays(se.filt4)$logCPM)), stringsAsFactors = FALSE)

tt <- topTable(fit, coef = 2, n = Inf)
tt.filt <- tt[abs(tt$logFC)>3,]
tt.filt <- tt.filt[tt.filt$P.Value < 1e-5,]
head(tt)

ggplot(data=tt.filt) +
geom_point(aes(x=logFC,y=-log(P.Value),color=logCPM)) +
scale_colour_gradientn(colours=c("#000000" ,"#FF0000" ))+
geom_hline(yintercept=10, linetype="dashed", color = "black",size=1)+
geom_vline(xintercept = 3, linetype="dashed", 
                color = "black", size=1)+
  geom_vline(xintercept = -3, linetype="dashed", 
                color = "black", size=1)

```



```{r}
logCPM <- cpm(dge.filt4, log=TRUE, prior.count=3)
tumorExp <- rowMeans(logCPM[, se.filt4$type == "tumor"])
normalExp <- rowMeans(logCPM[, se.filt4$type == "normal"])
par(mfrow = c(1, 2))
plot(normalExp, tumorExp, xlab = "Tumor", ylab = "Normal", pch = ".", cex = 4, las = 1)
plot((tumorExp + normalExp)/2, tumorExp - normalExp, pch = ".", cex = 4, las = 1)

log2fc <- tumorExp - normalExp
ranking <- order(abs(log2fc), decreasing = TRUE)

DEG <- data.frame(
  Log2FC = round(log2fc[ranking], digits = 3),
  FC = round(2^log2fc[ranking], digits = 3),
  `1/FC` = round(2^(-log2fc[ranking]), digits = 3),
  logCPM = as.numeric(rowMeans(assays(se.filt4)$logCPM)),
  `p-value` = as.numeric(pvsv), row.names = rowData(se.filt4)$symbol[ranking],
  check.names = FALSE)
DEG$BonfCutoff <- rep(0.05/nrow(DEG), nrow(DEG))
DEG$BonfPvalue <- p.adjust(DEG$`p-value`, method = "bonferroni")
DEG$FDRcutoff <- (1:nrow(DEG) * 0.05)/nrow(DEG)
DEG$FDRpvalue <- p.adjust(DEG$`p-value`, method = "fdr")
DEG
plot(DEG$Log2FC, -log10(DEG$`p-value`), pch=".", cex=3, xlab="Log fold-change", ylab="Raw p-value", las=1)
SDEG <- DEG[DEG$FDRpvalue < 1e-4,]
plot(SDEG$Log2FC, -log10(SDEG$FDRpvalue), pch=".", cex=3, xlab="Log fold-change", ylab="Raw p-value", las=1)
SDEG2 <- SDEG[abs(SDEG$Log2FC) > 4 ,]
plot(SDEG2$Log2FC, -log10(SDEG2$FDRpvalue), pch=".", cex=3, xlab="Log fold-change", ylab="Raw p-value", las=1)
abline(h=-log10(max(DEG$`p-value`[SDEG$FDRpvalue <= 0.05])), lty=2)
OEG <- SDEG2[SDEG2$Log2FC > 4,]
UEG <- SDEG2[SDEG2$Log2FC < -4,]
```



```{r sessioninfo}
sessionInfo()
```

# References
